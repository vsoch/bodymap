{% extends "base.html" %}

{% block head %}
<script src="{{ url_for('static', filename='js/topojson.js') }}"></script>
<script src="{{ url_for('static', filename='js/queue.js') }}"></script>
<style>
.pixel {
  cursor: pointer;
}

.tooltip {
  padding:10px;
  border-radius:4px;
}

#tags {
 position:fixed;
 bottom:10px;
 left:0px;
 z-index:2;
}

#timeline {
  position: fixed;
  bottom:20px;
  z-index:100;
}

.extent {
  fill: orange;
  opacity: 0.40;
}

.btn {
  margin-right:2px;
  background-color:white;
  color:black;
}

.area {
  fill: steelblue;
  clip-path: url(#clip);
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.brush .extent {
  stroke: #fff;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}

</style>
{% endblock %}
    
{% block content %}
<div id="bodyparts" style="position:fixed;top:5px;right:10px;width:100px;height:50px">
  <h4 id="message" style="color:white">BODYMAP</h4>
</div>
        <div class="row">
            <div class="col-md-9" id="map">
            </div>
            <div class="col-md-3">
                {{ bodymap | safe }}
            </div>
        </div>
        <div class="row">
            <div class="col-md-12" id="tags">
               <!-- buttons for each tag will be appended here-->
            </div>
        </div>
        <div id="timeline">
        </div>
{% endblock %}

{% block scripts %}
    <script type="text/javascript">

    var descriptions = {{ descriptions | safe }}

    $(document).ready(function() {
        var counts = {{ deaths | safe }}

        d3.selectAll(".pixel").attr("style","fill:white;stroke:none")
        d3.selectAll(".pixel").each(function(d){ 
           d3.select(this).on("mouseover",function(){
               var comps = $(this).attr("d").split(" ")
               comps[8]="8.2728431,8.2728431"               
               $(this).attr("d",comps.join(" "))
               var bodyparts = $(this).attr("class").replace("pixel","")
               $("#message").text(bodyparts)
           })
           d3.select(this).on("mouseout",function(){
               var comps = $(this).attr("d").split(" ")
               comps[8]="2.2728431,2.2728431" 
               $(this).attr("d",comps.join(" "))

           })
           d3.select(this).on("click",function(){
               var parts = $(this).attr("class").replace("pixel","").split(" ")
               parts.shift()
               $.each(parts,function(i,b){
                   var idx = counts[b]
                   if(typeof idx != 'undefined'){
                       idx = "circle#id" + idx.join(", circle#id")
                       $(idx).attr("style","fill:orange")
                       $(idx).attr("r",4)
                   }
                   // Add a button to the list
                   var active_parts = $.map($("button"), function( val, i ) {
                      return $(val).attr("id")
                   }); 
                   if ($.inArray(b + "_button",active_parts)==-1){
                       $("#tags").append('<button class="btn btn-xs" id="' + b + '_button"><i class="fa fa-times"></i> ' + b + '</button>')               
                   }

                   // On click, we should unselect points and remove button
                   $("#" + b + "_button").click(function(){
                       $("."+b).attr("style","fill:white;stroke:none")
                       $(idx).attr("style","fill:white")
                       $(idx).attr("r",1)
                       $(this).remove()
                   })

               })
               parts = parts.join(", .").replace("body","")
               $(parts).attr("style","fill:orange;stroke:none")
           })

        });

   // Let's make a map!
   var  width = 1200,
	height = 800;

   var proj = d3.geo.mercator()
       .center([-100, 50])
       .scale(600)
       .rotate([-10,0]);

    var path = d3.geo.path()
	.projection(proj);

    var zoom = d3.behavior.zoom()
        .translate(proj.translate())
        .scale(proj.scale())
        .scaleExtent([height*.33, 4 * height])
        .on("zoom", zoom);

    var svg = d3.select("#map").append("svg")
	.attr("width", width)
	.attr("height", height)
	.call(zoom);

    function zoom() {
	proj.translate(d3.event.translate).scale(d3.event.scale);
	svg.selectAll("path").attr("d", path);
	circles
  		.attr("cx", function(d){return proj([d.long, d.lat])[0];})
		.attr("cy", function(d){return proj([d.long, d.lat])[1];});
    }

    var borders = svg.append("g");
    var deaths = svg.append("g");
    var colorScale = d3.scale.linear().domain([1400, 1800, 1860, 1940, 2015]);

    var tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 1e-6)
        .style("background", "rgba(250,250,250,.7)");

    //tooltip.append("img")
	//.attr("id", "tooltipImg")
	//.attr("height", 100)
	//.attr("width", 100)
	//.style("opacity", "1");

    queue()
	.defer(d3.json, "{{ url_for('static', filename='worldTopo.json') }}")
	.defer(d3.json, "{{ url_for('static', filename='geopoints.json') }}")
	.await(ready);

    points = [];
    function ready(error, topology, geopoints){
	borders.selectAll("path")
		.data(topojson.object(topology, topology.objects.countries)
				.geometries)
	.enter()
		.append("path")
		.attr("d", path)
		.attr("class", "border")
	
	points = [];
	geopoints.features.forEach(function(d){
		d.lat = +d.geometry.coordinates[1];
		d.long = +d.geometry.coordinates[0];
		d.id = +d.id;
                points.push(d)
	});
	points.sort(function(a, b){return a.id - b.id;})

	colorScale
		.range(["#FFFF66", "#FFFF00", "#E68000", "#D94000", "#CC0000"]);

	circles = deaths.selectAll("circle")
		.data(points).enter()
			.append("svg:a")
		    	.attr("xlink:href", function(d) { return "#" })
		    	.attr("xlink:show", "new")
			.append("circle")
				.attr("cx", function(d){return proj([d.long, d.lat])[0];})
				.attr("cy", function(d){return proj([d.long, d.lat])[1];})
				.attr("r", 1)
				.attr("id", function(d){return "id" + d.id;})
				.style("fill", "white")
		.on("mouseover", function(d){
			d3.select(this)
				.attr("stroke", "black")
				.attr("stroke-width", 1)
				.attr("fill-opacity", 1);

			tooltip
			    .style("left", (d3.event.pageX + 5) + "px")
			    .style("top", (d3.event.pageY - 5) + "px")
			    .transition().duration(300)
			    .style("opacity", 1)
			    .style("display", "block")
                            .text(descriptions[d.id])
			})

		.on("mouseout", function(d){
			d3.select(this)
				.attr("stroke", "")
				.attr("fill-opacity", function(d){return 1;})

			tooltip.transition().duration(700).style("opacity", 0);
		});



	function render(method){
		d3.select(this).call(method);
	}


	lastFilterArray = [];
	points.forEach(function(d, i){
		lastFilterArray[i] = 1;
	});
        


        // Date slider
        formatDate = d3.time.format("%b %Y");

        // scale function
        var timeScale = d3.time.scale()
        .domain([new Date('{{ start_date }}'),new Date('{{ end_date }}')])
        .range([0, width])
        .clamp(true);

        // initial value
        var startingValue = new Date('3/20/2010');
        var endValue = timeScale(new Date('5/20/2012'));
        var sliderHeight = 50;

        // defines brush
        var margin = {top: 5, right: 20, bottom: 30, left: 40}
        var brush = d3.svg.brush()
            .x(timeScale)
            .extent([startingValue, endValue])
                .on("brush", brushed)

        var svgd = d3.select("#timeline").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", sliderHeight + 50 + margin.top + margin.bottom)
            .append("g")
            // classic transform to position g
           .attr("transform", "translate(" + margin.left + "," + sliderHeight + ")");

        svgd.append("defs").append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("width", width)
            .attr("height", sliderHeight);

        svgd.append("g")
            .attr("class", "x axis")
            // put in middle of screen
            .attr("transform", "translate(-10," + sliderHeight + ")")

           // inroduce axis
          .call(d3.svg.axis()
              .scale(timeScale)
              .orient("bottom")
              .tickFormat(function(d) {
                  return formatDate(d);
               })
           .tickSize(0)
           .tickPadding(12)
           .tickValues([timeScale.domain()[0], timeScale.domain()[1]]))
           .select(".domain")
           .select(function() {
               console.log(this);
               return this.parentNode.appendChild(this.cloneNode(true));
            })
           .attr("class", "halo");

           var slider = svgd.append("g")
               .attr("class", "slider context")
               .call(brush)
               .selectAll("rect")
               .attr("y", -6)
               .attr("height", sliderHeight + 7);

           slider.select(".background")
               .attr("height", sliderHeight);

           var handle = slider.append("g")
               .attr("class", "handle")

           handle.append("path")
               .attr("transform", "translate(0," + sliderHeight + ")")
               .attr("d", "M 0 -20 V 20")

           handle.append('text')
              .text(startingValue)
              .attr("transform", "translate(" + (-18) + " ," + (sliderHeight - 25) + ")");

           slider
               .call(brush.event)

           function brushed() {
               var value = brush.extent()[0];
               if (d3.event.sourceEvent) { // not a programmatic event
                    value = timeScale.invert(d3.mouse(this)[0]);
               }

               // Update the date to include these dates
               var start_date = brush.extent()[0].getFullYear()
               var end_date = brush.extent()[1].getFullYear()
               var url = "/api/dates/" + start_date + "/" + end_date
               console.log(url)

               // Retrieve date list via ajax call
               $.ajax({
                   type: "GET",
                   url: url,
                   // if this were not local, would want csrftoken here under data
                   complete: function (data, error){
                       var results = JSON.parse(data.responseText);
                       console.log(results);
                       $.each(results,function(i,e){
                             //console.log(e)
                       });
                    },
                       dataType: 'html',
                   });

                   timeScale.domain(brush.empty() ? timeScale.domain() : brush.extent());
                   handle.select('text').text(formatDate(value));
                   handle.attr("transform", "translate(" + timeScale(value) + ",0)");
                 }
 
                 // Make the slider look nice
                 d3.select('.extent')
                     .style('opacity','0.125')

    }// end function ready


    });//document ready
    </script>
{% endblock %}
